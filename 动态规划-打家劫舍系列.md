# 动态规划-打家劫舍系列

## 198. 打家劫舍

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

示例 1：

输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
示例 2：

输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。


提示：

* 0 <= nums.length <= 100
* 0 <= nums[i] <= 400

**第一步，定义dp数组**

`dp[i]`代表到第`i`间房屋时所能获取的最高金额

**第二步，`base case`初始化参数**

如果`nums.length == 0`，直接返回`0`

如果`nums.length == 1`，直接返回`nums[0]`

如果`nums.length > 1`，`dp[0] = nums[0]`，`dp[1] = Math.max(nums[0], nums[1])`

**第三步，状态转移方程**

`dp[i] = Math.max(dp[i-1], nums[i] + dp[i-2])`

**代码**

```java
public int rob(int[] nums) {
        if(nums == null || nums.length == 0) return 0;
        if(nums.length == 1) return nums[0];
        int[] dp = new int[nums.length];
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0],nums[1]);
        for(int i = 2; i < nums.length; i++){
            dp[i] = Math.max(dp[i-1],dp[i-2]+nums[i]);
        }
        return dp[nums.length-1];
    }
```

## 213. 打家劫舍 II

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。

示例 1:

输入: [2,3,2]
输出: 3
解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
示例 2:

输入: [1,2,3,1]
输出: 4
解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
     偷窃到的最高金额 = 1 + 3 = 4 。

**此题目与打家劫舍基本一致，唯一的不同就是房屋是围成一个圈，这意味着`nums[0]`与`nums[nums.length-1]`不能同时取到，此时有三种情况**

* **取`nums[0]`，从`nums[0]`到`nums[nums.length-2]`进行偷窃**
* **取`nums[nums.length-1]`，从`nums[1]`到`nums[nums.length-1]`进行偷窃**
* **`nums[0]`、`nums[nums.length-1]`都不取，从`nums[1]`到`nums[nums.length-2]`进行偷窃**

**其中，第三种情况包含在前两种之中，因此，只需要考虑前两种情况** 

**代码**

```java
 public int rob(int[] nums) {
        if(nums == null || nums.length == 0) return 0;
        if(nums.length == 1) return nums[0];
        if(nums.length == 2) return Math.max(nums[0],nums[1]);
        int[] dp = new int[nums.length];
        int result = 0;
        dp[0] = 0;
        dp[1] = nums[0];
        for(int i = 2; i < nums.length; i++){
            dp[i] = Math.max(dp[i-1],dp[i-2]+nums[i-1]);
        }
        result = dp[nums.length-1];
        dp[1] = nums[1];
        for(int i = 2; i < nums.length; i++){
            dp[i] = Math.max(dp[i-1],dp[i-2]+nums[i]);
        }
        result = Math.max(result,dp[nums.length-1]);
        return result;
    }
```

## 740. 删除与获得点数

给定一个整数数组 nums ，你可以对它进行一些操作。

每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后，你必须删除每个等于 nums[i] - 1 或 nums[i] + 1 的元素。

开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。

示例 1:

输入: nums = [3, 4, 2]
输出: 6
解释: 
删除 4 来获得 4 个点数，因此 3 也被删除。
之后，删除 2 来获得 2 个点数。总共获得 6 个点数。
示例 2:

输入: nums = [2, 2, 3, 3, 3, 4]
输出: 9
解释: 
删除 3 来获得 3 个点数，接着要删除两个 2 和 4 。
之后，再次删除 3 获得 3 个点数，再次删除 3 获得 3 个点数。
总共获得 9 个点数。
注意:

nums的长度最大为20000。
每个整数nums[i]的大小都在[1, 10000]范围内。

**思路：当获得`nums[i]`的点数时，必须删除点数为`nums[i]-1`和`nums[i]+1`的元素，假如我们对`nums`数组按元素大小从小到大进行排列，该题目就变成了打家劫舍问题，对于是否取大小为`nums[i]`的元素，取决于取`nums[i-1]`和取`nums[i]`、`nums[i-2]`哪个更大。**

**对`nums`数组进行改造**

```java
        int max = nums[0];
        for (int i = 1; i < nums.length; ++i) {
           max = Math.max(max, nums[i]);
        }
//      构造一个新的数组all
        int[] all = new int[max + 1];
        for (int item : nums) {
            all[item] ++;
        }
```

获取`all`数组，按`nums`数组元素大小从小到大排列，`all[i]`的值为`nums`数组元素大小为`i`的元素个数

**定义`dp`数组**

`dp[i]`表示到`nums`数组元素大小为`i`时所获得的最大点数

**`base case`初始化**

* `dp[0] = 0` 
* `dp[1] = all[1] * 1`
* `dp[2] = Math.max(dp[1], all[2] * 2)`

**状态转移方程**

`dp[i] = Math.max(dp[i-1], dp[i-2] + all[i] * i)`

**代码**

```java
public int deleteAndEarn(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        } else if (nums.length == 1) {
            return nums[0];
        }
        int max = nums[0];
        for (int i = 1; i < nums.length; ++i) {
           max = Math.max(max, nums[i]);
        }
//      构造一个新的数组all
        int[] all = new int[max + 1];
        for (int item : nums) {
            all[item] ++;
        }
        int[] dp = new int[max + 1];
        dp[1] = all[1] * 1;
        dp[2] = Math.max(dp[1], all[2] * 2);
//      动态规划求解
        for (int i = 2; i <= max; ++i) {
            dp[i] = Math.max(dp[i - 1], dp[i - 2] + i * all[i]);
        }
        return dp[max];
    }
```



