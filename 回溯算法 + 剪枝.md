# 回溯算法 + 剪枝

![60.第k个排列（1）](D:\TyporaNote\力扣\60.第k个排列（1）.png)

![60.第k个排列（2）](D:\TyporaNote\力扣\60.第k个排列（2）.png)

如果单纯使用回溯算法，会超出时间限制

```java
class Solution {
    List<String> list = new ArrayList<>();

   public String getPermutation(int n, int k) {
        int[] nums = new int[n];
        for (int i = 0; i < n; i++) {
            nums[i] = i + 1;
        }
        StringBuilder sb = new StringBuilder();
        backTrack(sb,nums);
        int index = 1;
        for(String s : list){
            if(index++ == k) return s;
        }
        return null;
    }

    public void backTrack(StringBuilder sb, int[] nums) {
        if(sb.length() == nums.length){
            list.add(sb.toString());
            return;
        }
        for(int i = 0; i < nums.length; i++){
            //剔除已在路径内容
            if(sb.indexOf(String.valueOf(nums[i])) != -1){
                continue;
            }
            sb.append(nums[i]);
            backTrack(sb,nums);
            sb.deleteCharAt(sb.length()-1);
        }
        return;
    }
}
```

这是因为把全部情况都进行计算，此时需要`剪枝`操作：

* 所求排列 一定在叶子结点处得到，进入每一个分支，可以根据已经选定的数的个数，进而计算还未选定的数的个数，然后计算阶乘，就知道这一个分支的 叶子结点 的个数：
  * 如果 k 大于这一个分支将要产生的叶子结点数，直接跳过这个分支，这个操作叫「剪枝」；
  * 如果 k 小于等于这一个分支将要产生的叶子结点数，那说明所求的全排列一定在这一个分支将要产生的叶子结点里，需要递归求解。



```java
class Solution {
     boolean[] used;

    //求阶乘
    public int factorial(int n) {
        int res = 1;
        while (n > 0) {
            res *= n--;
        }
        return res;
    }

    public String getPermutation(int n, int k) {
        int[] nums = new int[n];
        for (int i = 0; i < n; i++) {
            nums[i] = i + 1;
        }
        used = new boolean[n];
        Arrays.fill(used,false);
        StringBuilder sb = new StringBuilder();
        return backTrack(sb, nums, 0, k);
    }

    public String backTrack(StringBuilder sb, int[] nums, int deep, int k) {
        if (deep == nums.length) {
            return sb.toString();
        }
        // 计算还没确定的数字的全排列个数
        int c = factorial(nums.length - deep - 1);
        for (int i = 0; i < nums.length; i++) {
            // 判断该数字是否使用过
            if (used[i]) {
                continue;
            }
            // 还没确定的数字的全排列个数与k进行比较，如果 c < k，说明当前情况不满足
            if (c < k) {
                k -= c;
                continue;
            }
            used[i] = true;
            sb.append(nums[i]);
            //没有回溯的必要（减去不需要的计算）
            return backTrack(sb, nums, deep + 1, k);
        }
        return null;
    }
}
```

