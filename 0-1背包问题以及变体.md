# 0-1背包问题以及变体

## 0-1背包

给你一个可装载重量为`W`的背包和`N`个物品，每个物品有重量和价值两个属性。其中第`i`个物品的重量为`wt[i]`，价值为`val[i]`，现在让你用这个背包装物品，最多能装的价值是多少？
如：

```html
N = 3, W = 4
wt = [2, 1, 3]
val = [4, 2, 3]
```

结果返回`6`，选择前两件物品装入背包，总重量`3`，价值`6`

**第一步，明确状态和选择**

状态：给定一个背包和可供选择的物品就形成了背包问题，所以状态有两种：1、背包的容量，2、可供选择的物品

选择：1、当前物品选择装入，2、选择不装入

**第二步，明确dp数组**

dp数组就是描述当前局面的一个数组，用dp数组把状态描述出来，由于有两个状态，因此需要二维数组：
`dp[i][j]`  ：表示背包容量为`j`，用前`i`个物品能凑出的最大价值

初始化条件：`dp[0...i][0]`=0，`dp[0][0...j]`=0：表示没有可选择物品或背包容量为0的时候价值为0

**第三步，状态转移方程**

对于第i个物品，我们有两个选择：

* 装入

  `dp[i][j]` = `dp[i-1][j-wt[i-1]]` + `val[i-1]`

  选择将第i个物品装入，则当前价值为第i个物品价值加上`dp[i-1][j-wt[i-1]]`

  `dp[i-1][j-wt[i-1]]`表示背包容量为`j-wt[i-1]`（减去第i个物品的重量）时使用前i-1个物品所凑出的最大价值

* 不装入

  `dp[i][j]` = `dp[i-1][j]`

  表示不使用第i个物品，背包容量为`j`时用前`i-1`个物品所凑出的最大价值

代码实现：

```java
public int knapsack(int W,int N,int[] val,int[] wt){
        int[][] dp = new int[N+1][W+1];
        //base case
        for(int i = 0; i <= N; i++) dp[i][0] = 0;
        for(int j = 0; j <= W; j++) dp[0][j] = 0;
        //状态转移
        for(int i = 1; i <= N; i++){
            for(int j = 1; j <= W; j++){
                if(j >= wt[i-1]){
                    dp[i][j] = Math.max(dp[i-1][j-wt[i-1]]+val[i-1],dp[i-1][j]);
                }else{
                    dp[i][j] = dp[i-1][j];
                }
            }
        }
        return dp[N][W];
    }
```

## 变体问题，分割等合子集

![416.分割等和子集](D:\TyporaNote\力扣\416.分割等和子集.jpg)

对于这个问题，我们可以先对集合求和，然后求和结果`sum`除以2，得出背包问题：
**给一个可装载重量为`sum/2`的背包和`N`个物品，每个物品的重量为`nums[i]`。现在让你装物品，是否存在一种装法，能够恰好将背包装满**？

**明确状态**

两个状态：**背包容量** 和 **可供选择物品**

**建立dp数组**

`dp[i][j]` = `x`：对于前`i`个物品，若`x` = 1，则代表前`i`个物品能将容量为`j`的背包填满

如`dp[4][9]`代表前`4`个物品，有一种方法能凑出容量为`9`

我们要求的最终答案便是`dp[N][sum/2]`

base case :  `dp[0...i][0]` = `1` , `dp[0][0...j]` = `0`

**状态转移方程**

* 选择装入第`i`个物品：`dp[i][j] ` = `dp[i-1][j-nums[i-1]]`

  既然选择装入第`i`个物品，那只需看`dp[i-1][j-nums[i-1]]`是否为1

* 选择不装入，`dp[i][j] ` = `dp[i-1][j]`，不装入第`i`个物品，则看前`i-1`个物品能否填满容量`j`

代码实现：

```java
public boolean canPartition(int[] nums) {
        int sum = 0;
        for(int i = 0; i < nums.length; i++){
            sum += nums[i];
        }
        if(sum % 2 != 0) return false;
        sum /= 2;
        //定义dp数组
        //dp[i][j]表示使用前i个数组元素能否取得大小为j，1表示可以，0表示不可
        int[][] dp = new int[nums.length+1][sum+1];
        for(int i = 0; i <= sum; i++){
            dp[0][i] = 0;
        }
        for(int i = 0; i <= nums.length; i++){
            dp[i][0] = 1;
        }
        for(int i = 1; i <= nums.length; i++){
            for(int j = 1; j <= sum; j++){
                if(j >= nums[i-1]){
                    dp[i][j] = dp[i-1][j - nums[i-1]];
                    if(dp[i][j] == 1) continue;
                }
                dp[i][j] = dp[i-1][j];
            }
            if(dp[i][sum] == 1) return true;
        }
        return false;
    }
```

优化，压缩到一维，在第二层遍历时，需要采用逆序遍历，保证每个元素只使用一次

```java
public boolean canPartition(int[] nums) {
        int sum = 0;
        for(int i = 0; i < nums.length; i++){
            sum += nums[i];
        }
        if(sum == 0) return true;
        if(sum % 2 != 0) return false;
        sum = sum / 2;
        int[] dp = new int[sum+1];
        dp[0] = 1;
        for(int i = 0; i < nums.length; i++){
            for(int j = sum; j >= 0; j--){
                if(j >= nums[i] && dp[j] != 1){
                    dp[j] = dp[j-nums[i]];
                }
            }
            if(dp[sum] == 1) return true;
        }
        return false;
    }
```



## 变体问题，目标和

![494.目标和](D:\TyporaNote\力扣\494.目标和.jpg)

这个问题可以转移为子集问题，而子集问题又是背包问题。

我们把 `nums` 分为子集 `A` 和子集 `B`，目标数为`S`，则有：

* `S` = `sum(A)` - `sum(B)`
* `sum(A)` = `sum(B)` + `S`
* `sum(A)` + `sum(A)` = `sum(B)` + `S` + `sum(A)` 
* `2sum(A)`  = `sum` + `S`
* `sum(A)` = (`sum` + `S`) / 2

如此，把原问题转为：存在多少个子集`A`，使得子集和为 (`sum` + `S`) / 2

转为背包问题：

**有一个背包，容量为 `sum`，现在给你 `N` 个物品，第 `i` 个物品的重量为 `nums[i - 1]`（注意 `1 <= i <= N`），每个物品只有一个，请问你有几种不同的方法能够恰好装满这个背包**？

代码实现：

```java
 public int findTargetSumWays(int[] nums, int S) {
        int len = nums.length;
        int sum = 0;
        for(int i = 0; i < len; i++){
            sum += nums[i];
        }
        if(sum < S || (sum + S) % 2 == 1) return 0;
        sum = (sum + S) / 2;
        //定义dp数组
        int[][] dp = new int[nums.length+1][sum+1];
        //初始化
        for(int i = 0; i <= nums.length; i++) dp[i][0] = 1;
        for(int j = 1; j <= sum; j++) dp[0][j] = 0;
        for(int i = 1; i<= nums.length; i++){
            //j要从0开始
            for(int j = 0; j <= sum; j++){
                if(j >= nums[i-1]) dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i-1]];
                else dp[i][j] = dp[i-1][j];
            }
        }
        return dp[nums.length][sum];
    }
```

值得注意的测试用例：

```java
nums:[0,0,0,0,0,0,0,0,1]
S:1
```

这要求`j`必须从`0`开始遍历，而不是像之前的背包问题一样：`dp[0..i][0]` = `1`
如上面测试用例，前两个物品`0`可以凑出`4`种状态`0`，而不是1种。**要注意值能不能取0的问题**

## 变体问题，一和零

![474.一和零（1）](D:\TyporaNote\力扣\474.一和零（1）.png)

![474.一和零（2）](D:\TyporaNote\力扣\474.一和零（2）.png)

思路：该问题也是背包问题，数组`Array`代表可供选择的物品，每个数组元素`0`、`1`的数量则代表所需的容量，而每个物品的价值都是1。

**定义`dp`数组**

`int[][][] dp = new int[strs.length+1][m+1][n+1]`，`dp[i][j][k]`代表：使用前`i`个物品，容量为`j`个`0`、`k`个`1`所能容纳的最大数量。

**状态转移方程**

对于每个字符串，`ones`代表该字符串`1`的数量，`zeros`代表该字符串`0`的数量

* 如果`j`>=`zeros`，`k`>=`ones`，则` dp[i][j][k] = Math.max(dp[i-1][j][k],dp[i-1][j-zeros][k-ones]+1)`
* 否则` dp[i][j][k] = dp[i-1][j][k]`

**代码**

```java
public int findMaxForm(String[] strs, int m, int n) {
        int[][][] dp = new int[strs.length+1][m+1][n+1];
        for(int i = 1; i <= strs.length; i++){
            for(int j = 0; j <= m; j++){
                for(int k = 0; k <= n; k++){
                    int[] chars = getChar(strs[i-1]);
                    int ones = chars[1];
                    int zeros = chars[0];
                    if(j >= zeros && k >= ones){
                        dp[i][j][k] = Math.max(dp[i-1][j][k],dp[i-1][j-zeros][k-ones]+1);
                    }else{
                        dp[i][j][k] = dp[i-1][j][k];
                    }
                }
            }
        }
        return dp[strs.length][m][n];
    }

    public int[] getChar(String s){
        int[] result = new int[2];
        for(char c : s.toCharArray()){
            result[c-48]++;
        }
        return result;
    }
```

优化：

我们观察到，每个`dp数组的值`只与`j、k`有关，因此，可以用二维数组解决

因为每个数组元素只能用一次，是`0-1`背包问题，因此，我们需要**逆序遍历**，防止重复选择

```java
public int findMaxForm(String[] strs, int m, int n) {
        int[][] dp = new int[m+1][n+1];
        for(String s : strs){
            int[] chars = getChar(s);
            //逆序遍历，防止重复选择元素
            for(int i = m; i >= 0; i--){
                for(int j = n; j >= 0; j--){
                    if(i >= chars[0] && j >= chars[1]){
                        dp[i][j] = Math.max(dp[i-chars[0]][j-chars[1]]+1,dp[i][j]);
                    }else{
                        dp[i][j] = dp[i][j];
                    }
                }
            }
        }
        return dp[m][n];
    }

    public int[] getChar(String s){
        int[] result = new int[2];
        for(char c : s.toCharArray()){
            result[c-48]++;
        }
        return result;
    }
```

