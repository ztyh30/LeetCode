# 滑动窗口

## 框架

```c++
/* 滑动窗口算法框架 */
void slidingWindow(string s, string t) {
    unordered_map<char, int> need, window;
    for (char c : t) need[c]++;

    int left = 0, right = 0;
    int valid = 0; 
    while (right < s.size()) {
        // c 是将移入窗口的字符
        char c = s[right];
        // 右移窗口
        right++;
        // 进行窗口内数据的一系列更新
        ...

        /*** debug 输出的位置 ***/
        printf("window: [%d, %d)\n", left, right);
        /********************/

        // 判断左侧窗口是否要收缩
        while (window needs shrink) {
            // d 是将移出窗口的字符
            char d = s[left];
            // 左移窗口
            left++;
            // 进行窗口内数据的一系列更新
            ...
        }
    }
}
```



## 3. 无重复字符的最长子串

给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。

示例 1:

```
输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

示例 2:

```
输入: "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```

示例 3:

```
输入: "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```



滑动窗口解决

思路：要找的是无重复字符的最长子串，使用`left`代表左指针，`right`代表右指针

左闭右开`[left,right)`作为窗口`window`，`left`和`right`初始化为0

首先，不断向右移动右指针，判断要加入集合的字符（窗口`window`）是否是已存在的，如果未存在，则判断是否更新`len`长度，如果已存在，则要移动左指针，直到满足集合（窗口`window`）内没有重复字符

比如`abcabcaa`，前三个字符依次加入`window`窗口，长度`len`为3，当第二个字符a加入后，`window`窗口更新为`bca`，依此类推



```java
public int lengthOfLongestSubstring(String s) {
        Map<Character,Integer> window = new HashMap<>();
        int left = 0, right = 0, len = 0;
        while(right < s.length()){
            char c1 = s.charAt(right++);
            if(window.containsKey(c1)){
                window.put(c1,2);
                while(!window.get(c1).equals(1)){
                    char c2 = s.charAt(left++);
                    if(c2 == c1){
                        window.put(c1,1);
                    }else{
                        window.remove(c2);
                    }
                }
            }else{
                len = right - left > len ? right - left : len;
                window.put(c1,1);
            }
        }
        return len;
```

## 76.最小覆盖子串

给你一个字符串 S、一个字符串 T 。请你设计一种算法，可以在 O(n) 的时间复杂度内，从字符串 S 里面找出：包含 T 所有字符的最小子串。

示例：

```
输入：S = "ADOBECODEBANC", T = "ABC"
输出："BANC"
```


提示：

如果 S 中不存这样的子串，则返回空字符串 ""。
如果 S 中存在这样的子串，我们保证它是唯一的答案。

**思路：**用滑动窗口解决

***1、***我们在字符串`S`中使用双指针中的左右指针技巧，初始化`left = right = 0`，**把索引左闭右开区间`[left, right)`称为一个「窗口」**。

***2、***我们先不断地增加`right`指针扩大窗口`[left, right)`，直到窗口中的字符串符合要求（包含了`T`中的所有字符）。

***3、***此时，我们停止增加`right`，转而不断增加`left`指针缩小窗口`[left, right)`，直到窗口中的字符串不再符合要求（不包含`T`中的所有字符了）。同时，每次增加`left`，我们都要更新一轮结果。

***4、***重复第 2 和第 3 步，直到`right`到达字符串`S`的尽头。

**第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解**

**其中`valid`变量表示窗口中满足`need`条件的字符个数**，如果`valid`和`need.size`的大小相同，则说明窗口已满足条件，已经完全覆盖了串`T`。

```java
public String minWindow(String s, String t) {
        if(s == null || t == null || s == "" || t == "" || s.length() < t.length()) return "";
        Map<Character,Integer> window = new HashMap<>();
        Map<Character,Integer> need = new HashMap<>();
        for(int i = 0; i < t.length(); i++){
            need.put(t.charAt(i),need.getOrDefault(t.charAt(i),0)+1);
        }
        int left = 0, right = 0, start = 0, valid = 0, len = Integer.MAX_VALUE;
        while(right < s.length()){
            char c1 = s.charAt(right++);
            //如果字符是need里所拥有的，则加入window
            if(need.containsKey(c1)){
                window.put(c1,window.getOrDefault(c1,0)+1);
                //判断逻辑内容是否相同，应当用equals，不能用==
                //Integer在-128-127之外会新建对象，不能用==判断
                if(window.get(c1).equals(need.get(c1))) valid++;
            }
            //左指针向右移动
            while(valid == need.size()){
                char c2 = s.charAt(left);
                if(need.containsKey(c2)){
                    //如果此时window拥有该字符的和need里的该字符一样，则去掉该字符就不满足valid==need.size()了，因此应该更新
                    if(window.get(c2).equals(need.get(c2))) {
                        if(right - left < len){
                            len = right - left;
                            start = left;
                        }
                        valid--;
                    }
                }
                window.put(c2,window.getOrDefault(c2,1)-1);
                left++;
            }
        }
        return len == Integer.MAX_VALUE ? "" : s.substring(start,start+len);
    }
```

## 567.字符串的排列

给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。

换句话说，第一个字符串的排列之一是第二个字符串的子串。

示例1:

```
输入: s1 = "ab" s2 = "eidbaooo"
输出: True
解释: s2 包含 s1 的排列之一 ("ba").
```

示例2:

```
输入: s1= "ab" s2 = "eidboaoo"
输出: False
```


注意：

输入的字符串只包含小写字母
两个字符串的长度都在 [1, 10,000] 之间

思路：滑动窗口解决

新建两个`HashMap`:`need`保存字符串`s1`出现的字符的次数，`window`用来保存当前窗口记录字符串的情况

```java
public boolean checkInclusion(String s1, String s2) {
        Map<Character,Integer> need = new HashMap<>();
        Map<Character,Integer> window = new HashMap<>();
        for(int i = 0; i < s1.length(); i++){   need.put(s1.charAt(i),need.getOrDefault(s1.charAt(i),0)+1);
        }
        int left = 0, right = 0, result = 0;
        while(right < s2.length()){
            char c1 = s2.charAt(right++);
            //如果字符属于s1，则加入窗口
            if(need.containsKey(c1)){
                window.put(c1,window.getOrDefault(c1,0)+1);
                if(window.get(c1).equals(need.get(c1))) result++;
                if(window.get(c1) > need.get(c1)){
                    while(!window.get(c1).equals(need.get(c1))){
                        char c2 = s2.charAt(left++);
                        if(window.get(c2).equals(need.get(c2))) result--;
                        window.put(c2,window.getOrDefault(c2,1)-1);
                    }
                }
            }else{
                window.clear();
                result = 0;
                left = right;
            }
            if(result == need.size()) return true;
        }
        return false;
    }
```



