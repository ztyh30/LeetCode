# 完全背包问题

## 518. 零钱兑换 II

给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 

示例 1:

```输入: amount = 5, coins = [1, 2, 5]
输出: 4
解释: 有四种方式可以凑成总金额:
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
输入: amount = 5, coins = [1, 2, 5]
```

示例 2:

```输入: amount = 3, coins = [2]
输出: 0
解释: 只用面额2的硬币不能凑成总金额3。
输入: amount = 3, coins = [2]
```

示例 3:

```
输入: amount = 10, coins = [10] 
输出: 1
```


注意:

你可以假设：

* 0 <= amount (总金额) <= 5000
* 1 <= coin (硬币面额) <= 5000
* 硬币种类不超过 500 种
* 结果符合 32 位符号整数

**思路：**

转换成背包问题：有一个背包，最大容量为`amount`，有一系列物品`coins`，每个物品的重量为`coins[i]`，**每个物品的数量无限**。请问有多少种方法，能够把背包恰好装满？

**定义`dp`数组**

`dp[i][j]`：**若只使用前`i`个物品，当背包容量为`j`时，有`dp[i][j]`种方法可以装满背包**

**base case初始化**

`dp[0...i][0] = 1`，背包容量为0时，无需任何硬币

`dp[0][1...j] = 0`，没有硬币时，凑不出目标金额

**状态转移方程**

* 如果不把第`i`个物品放入背包，那么`dp[i][j] = dp[i-1][j]`，等于用前`i-1`个物品填满容量为`j`的背包的方法数

* 如果把第`i`个物品放入背包，那么`dp[i][j] = dp[i-1][j] + dp[i][j-coins[i-1]]`，相当于用前`i-1`个物品填满容量为`j`的背包的方法数加上用前`i`个物品填满容量为`j-coins[i-1]`的背包的方法数

  因为硬币无限，所以是`dp[i][j-coins[i-1]]`而不是

  `dp[i-1][j-coins[i-1]]`

**代码**

```java
public int change(int amount, int[] coins) {
        if(amount == 0) return 1;
        //定义dp
        int[][] dp = new int[coins.length+1][amount+1];
        //base case
        for(int i = 0; i <= coins.length ; i++){
            dp[i][0] = 1;
        }
        for(int j = 1; j <= amount; j++){
            dp[0][j] = 0;
        }
        //状态转移
        for(int i = 1; i <= coins.length; i++){
            for(int j = 1; j <= amount; j++){
                if(j >= coins[i-1]){
                    dp[i][j] = dp[i-1][j] + dp[i][j-coins[i-1]];
                }else{
                    dp[i][j] = dp[i-1][j];
                }
            }
        }
        return dp[coins.length][amount];
    }
```

通过观察可以发现，`dp`数组的转移只和`dp[i][..]`和`dp[i-1][..]`有关，所以可以压缩状态，进一步降低算法的空间复杂度：

**第二层递归正序遍历，表示每种硬币可以取无限个，而倒序遍历，每种硬币只能使用一次**

```java
 public int change(int amount, int[] coins) {
        if(amount == 0) return 1;
        int[] dp = new int[amount+1];
        dp[0] = 1;
        for(int i = 0; i < coins.length; i++){
            //正序遍历，每种硬币可以无限使用
            //倒序遍历，每种硬币只能使用一次
            for(int j = 1; j <= amount; j++){
                if(j >= coins[i]){
                    dp[j] = dp[j] + dp[j-coins[i]];
                }
            }
        }
        return dp[amount];
    }
```

## 322.零钱兑换

给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。

 示例 1:

```
输入: coins = [1, 2, 5], amount = 11
输出: 3 
解释: 11 = 5 + 5 + 1
```

示例 2:

```
输出: -1
输入: coins = [2], amount = 3
```

说明:
你可以认为每种硬币的数量是无限的。

**定义`dp`数组**

`dp[n]`：表示凑到金额为`n`时所需的最少硬币数

**base case初始化**

`dp[0] = 0`：金额为0时，无需任何硬币

`dp[1...amount] = amount + 1`：便于后续取最小值

**状态转移方程**

* 如果不选择`coins[i]`，`dp[j] = dp[j]`
* 选择`coins[i]`，`dp[j] = min{dp[j],dp[j-coins[i]]+1}`

**代码**

第二层递归正序遍历，代表硬币可取无限

```java
public int coinChange(int[] coins, int amount) {
        if(amount == 0) return 0;
        int[] dp = new int[amount+1];
        Arrays.fill(dp,amount+1);
        dp[0] = 0;
        for(int i = 0; i < coins.length; i++){
            for(int j = 1; j <= amount; j++){
                if(j >= coins[i]){
                    dp[j] = Math.min(dp[j],dp[j-coins[i]]+1);
                }
            }
        }
        if(dp[amount] == amount+1) return -1;
        return dp[amount];
    }
```





